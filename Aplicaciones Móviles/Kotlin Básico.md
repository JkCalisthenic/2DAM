- ---
- #LenguajeDeProgramaci√≥n
-  ---
## Creaci√≥n de variables
Existen dos maneras para rear una variable, pueden ser las siguientes:
- **Var:** Creaci√≥n de una variable que puede cambiar su valor en el resto del c√≥digo.
- **Val:** Creaci√≥n de una variable que su valor no va a cambiar nunca, es una variable constante.

``` kotlin
 // Ejemplos de creaci√≥n de variables
 var soyUnaVariable
 val soyUnaVariableConstante
```

Al igual que en todos los lenguajes, hay tipos de variables, ya sean enteros, boleanos...
Para asignar a una variable que sea de un tipo u otro, despu√©s del nombre deberemos poner dos puntos y el tipo de variable.
Ojo cuidado que en kotlin las variables se ponen con la primera letra en may√∫sculas, son consideradas directamente como Objetos.

``` Kotlin
var entero: Int
var decimal1: Float
var decimal2: Double
var boleano: Boolean
var cadena: String
var letra: Char
```

A las variables **var** podemos asignarle un valor predeterminado al crearlas, pero hay que tener cuidado ya que debemos tener en cuenta el valor nulo si es que no se le da.
El s√≠mbolo ? justo antes del signo = significa que puede tener tanto el valor null como cualquier valor seg√∫n el tipo de variable que sea.

``` kotlin
var variable: Int? = 4
```

## Mostrar cosas en la consola
Para mostrar cosas por consola es muy parecido con python:
``` kotlin
var num1: Int? = 20

// Sin salto de l√≠nea
print("Hola tengo " + num1 + " a√±os")

// Con salto de l√≠nea
println("Hola tengo " + num1 + " a√±os")

// Agregando una variable dentro de las comillas
println("Hola tengo $num1 a√±os")
```

## Condicional if y when
### Condicional if y uso del let
El condicional `if` nos sirve para redirigir el flujo de nuestro c√≥digo dependiendo de una condici√≥n que pongamos.

``` kotlin
var numero: Int? = 5

if (numero == null) {
	println("Soy un numero nulo")
} else if (numero >= 0) {
	println("Soy un numero positivo")
} else {
	println("Soy un numero negativo")
}
```
En este ejemplo comprobamos si `numero` es **nulo** y, si no lo es, evaluamos si es positivo o negativo.

Aunque parezca que esto es todo, tambi√©n podemos escribirlo de otra manera utilizando `let`.  `let` no reemplaza a `if`, pero combinado con el **safe call** `?.` nos permite ejecutar un bloque de c√≥digo **solo si la variable no es nula**.

``` kotlin
var numero: Int? = 5

numero?.let {
    if (it >= 0) {
        println("Soy un n√∫mero positivo")
    } else {
        println("Soy un n√∫mero negativo")
    }
} ?: println("Soy un n√∫mero nulo")

```
**Explicaci√≥n:** 
- El operador **safe call** **`?.`** asegura que el bloque `let` se ejecute solo si `numero` **no es nulo**.
- Dentro del bloque de `let`, la variable se pasa autom√°ticamente como **`it`**, por lo que **no es necesario usar el nombre original** (`numero`).
- El operador **Elvis (`?:`)** se ejecuta si `numero` **es nulo**, permitiendo definir un comportamiento alternativo.

üí° En otras palabras, `let` te permite **trabajar con el valor de la variable de manera segura y concisa**, evitando comprobaciones expl√≠citas de null.

**Otras funciones de alcance (_scope functions_)**

| Funci√≥n | Referencia al objeto | Modifica objeto? | Devuelve             | Funci√≥n / Uso principal                                                               |
| ------- | -------------------- | ---------------- | -------------------- | ------------------------------------------------------------------------------------- |
| `apply` | `this`               | S√≠               | El objeto            | Inicializar o configurar propiedades del objeto.                                      |
| `also`  | `it`                 | No               | El objeto            | Ejecutar acciones adicionales (logging, validaciones) sin modificar el objeto.        |
| `run`   | `this`               | Puede            | Resultado del bloque | Ejecutar un bloque de c√≥digo y devolver un valor, usando el objeto dentro del bloque. |
Todas estas funciones pueden ser **encadenadas** despu√©s de los corchetes, permitiendo escribir c√≥digo m√°s limpio y seguro.

### Condicional when
En Kotlin, `when` es un condicional m√°s **vers√°til y expresivo** que el cl√°sico `if-else if-else` o `switch`.
Se usa para **evaluar un valor y ejecutar un bloque de c√≥digo seg√∫n diferentes casos**.

``` kotlin
val numero: Int? = 5

when (numero) {
    null -> println("Soy un n√∫mero nulo")
    0 -> println("Soy cero")
    1 -> println("Soy uno")
    else -> println("Soy un n√∫mero distinto de cero y uno")
}
```
**Explicaci√≥n:**
- `when` compara el valor de `numero` con cada **caso** definido.
- Cada caso termina en `->` seguido del c√≥digo que queremos ejecutar.
- `else` funciona como el `else` de un `if`, y se ejecuta si ning√∫n caso coincide.
- Es **obligatorio** si no cubrimos todos los posibles valores (como con valores nulos o n√∫meros no previstos).


`when` tambi√©n puede **devolver un valor**, lo que evita usar variables temporales:

``` kotlin
val mensaje = when (numero) {
    null -> "N√∫mero nulo"
    0 -> "Cero"
    1 -> "Uno"
    else -> "Otro n√∫mero"
}

println(mensaje)
```

Esto hace el c√≥digo m√°s conciso y legible.

**Comparaciones posibles (simples):**

|Caso|Ejemplo|
|---|---|
|Igualdad simple|`0 -> println("Cero")`|
|Varios valores juntos|`1, 2 -> println("Peque√±o")`|
|Condici√≥n por defecto|`else -> println("Otro")`|
|Comprobar tipo|`is String -> println("Es texto")`|
## Operadores y constructos de rangos y colecciones

En Kotlin, existen varios **operadores y constructos** que permiten **comprobar pertenencia, definir rangos de valores y trabajar con colecciones de manera segura**.

``` Kotlin
// 1Ô∏è‚É£ in y !in con if
val numero = 7
if (numero in 1..5) println("N√∫mero entre 1 y 5")
if (numero !in 1..5) println("N√∫mero fuera del rango 1 a 5")

// 2Ô∏è‚É£ .. (rango inclusivo)
if (3 in 1..5) println("3 est√° en el rango de 1 a 5")

// 3Ô∏è‚É£ until (excluye √∫ltimo)
if (5 !in 0 until 5) println("5 no est√° en el rango 0 until 5") // 0..4

// 4Ô∏è‚É£ downTo (decremento)
if (3 in 5 downTo 1) println("3 est√° en el rango 5 downTo 1")

// 5Ô∏è‚É£ step (salto)
if (4 in 0..10 step 2) println("4 est√° en el rango 0..10 con step 2") 
// 0,2,4,6,8,10

// 6Ô∏è‚É£ in con colecciones
val vocales = listOf("a", "e", "i", "o", "u")
val letra = "e"

if (letra in vocales) println("$letra es una vocal")
if ("x" !in vocales) println("x no es una vocal")

// 7Ô∏è‚É£ Uso de when con in y !in
when (numero) {
	in 1..5 -> println("N√∫mero entre 1 y 5")
    in 6..10 -> println("N√∫mero entre 6 y 10")
    !in 1..10 -> println("N√∫mero fuera de 1 a 10")
}
```

| Operador / Constructo | Uso principal                              |
| --------------------- | ------------------------------------------ |
| `in` / `!in`          | Comprobar pertenencia en rango o colecci√≥n |
| `..`                  | Crear rangos inclusivos                    |
| `until`               | Crear rangos excluyendo el √∫ltimo valor    |
| `downTo`              | Rangos decrecientes                        |
| `step`                | Definir salto en rangos                    |
| `indices`             | Iterar sobre √≠ndices de listas/arrays      |
| `lastIndex`           | Obtener el √∫ltimo √≠ndice de una colecci√≥n  |
## Listas
### List (inmutable)
- Es **solo de lectura**: no puedes agregar, eliminar ni cambiar elementos despu√©s de crearla.
- Ideal para listas que no deben cambiar.

```kotlin
val numeros = listOf(1, 2, 3, 4)
println(numeros[0]) // 1
// numeros.add(5) ‚ùå Error: no se puede modificar
```

### MutableList
- Es **mutable**, puedes agregar, eliminar y modificar elementos libremente.

```kotlin
val numeros = mutableListOf(1, 2, 3)
numeros.add(4)      // ‚úÖ Agregar
numeros.remove(2)   // ‚úÖ Eliminar
numeros[0] = 10     // ‚úÖ Modificar
println(numeros)    // [10, 3, 4]

```

### ArrayList
- Crea una **lista basada en ArrayList de Java**.  
Es pr√°cticamente igual que mutableListOf, pero garantiza la implementaci√≥n concreta.

```kotlin
val lista = arrayListOf("a", "b", "c")
lista.add("d")
println(lista) // [a, b, c, d]

```

### EmptyList y EmptyMutableList
- Crean listas vac√≠as sin elementos.

```kotlin
val listaVacia = emptyList<String>()
val listaMutableVacia = mutableListOf<Int>()

```

### ListOfNotNull 
- Crea una lista que **omite los valores nulos** autom√°ticamente.

```kotlin
val lista = listOfNotNull(1, null, 3, null, 5)
println(lista) // [1, 3, 5]

```

## Clases
Una clase en kotlin se define con sus atributos:
```kotlin
// Definici√≥n de la clase Persona
class Persona(
    var nombre: String,    // Atributo 1
    var edad: Int,         // Atributo 2
    var ciudad: String     // Atributo 3
) {
    // Funci√≥n para mostrar informaci√≥n de la persona
    fun mostrarInfo() {
        println("Nombre: $nombre, Edad: $edad, Ciudad: $ciudad")
    }
}
```

En este caso hemos creado la clase Persona, la cual tiene nombre, edad y ciudad.
Si quisi√©ramos utilizar y acceder a la informaci√≥n de la clase:
```kotlin
fun main() {
    val persona1 = Persona("Ana", 25, "Madrid")
    persona1.mostrarInfo()
}
```
Primero crear√≠amos una variable donde guardamos a la Persona pas√°ndole los par√°metros desus atributos.
Y despu√©s podemos acceder a sus m√©todos mucho m√°s f√°cil que en java:

```kotlin
fun main() {
    val persona1 = Persona("Ana", 25, "Madrid")
    persona1.mostrarInfo()
    
    println(persona1.nombre)
    println(persona1.edad)
    println(persona1.ciudad)
}
```


### Herencia
La herencia permite que una clase herede propiedades y m√©todos de otra clase, evitando repetir c√≥digo.
#### Clase base o padre
Para permitir que otra clase herede de ella, la clase debe marcarse con la palabra clave open.
Por defecto, las clases en Kotlin son final (no se pueden heredar).

```kotlin
open class Persona(
    val nombre: String,
    val edad: Int
) {
    fun saludar() {
        println("Hola, mi nombre es $nombre")
    }
}

```
#### Clase derivada o hija
Se crea usando `:` seguido del nombre de la clase padre.
Debes llamar al constructor del padre si tiene par√°metros.

```kotlin
class Estudiante(
    nombre: String,
    edad: Int,
    val carrera: String
) : Persona(nombre, edad) {   // Hereda de Persona

    fun estudiar() {
        println("$nombre est√° estudiando $carrera")
    }
}

```

#### Sobrescribir m√©todos
Para permitir que un m√©todo sea sobrescrito, la funci√≥n del padre debe ser open.
En la clase hija se usa `override` para modificarlo.

```kotlin
open class Persona(
    val nombre: String
) {
    open fun presentarse() {
        println("Hola, soy $nombre")
    }
}

class Profesor(nombre: String, val materia: String) : Persona(nombre) {
    override fun presentarse() {
        println("Hola, soy $nombre y ense√±o $materia")
    }
}

```

#### Uso de super
Dentro de la clase hija, super se usa para llamar a m√©todos de la clase padre.

```kotlin
class Profesor(nombre: String, val materia: String) : Persona(nombre) {
    override fun presentarse() {
        super.presentarse()  // Llama al m√©todo de Persona
        println("Mi materia es $materia")
    }
}

```

### Clase public
- En Kotlin, todas las clases son public por defecto.
- Esto significa que pueden ser accedidas desde cualquier parte del proyecto.
- No necesitas escribir public expl√≠citamente, pero puedes hacerlo si quieres ser m√°s claro.

```kotlin
public class Vehiculo(val marca: String, val modelo: String)

fun main() {
    val miCoche = Vehiculo("Toyota", "Corolla")
    println(miCoche.marca)  // Toyota
}

```

### Clases sealed
- Una clase sealed permite controlar todas las subclases posibles.
- Es √∫til cuando quieres que todas las variaciones de una clase est√©n en el mismo archivo.
- Muy usado en when para cubrir todos los casos sin necesidad de else.

```kotlin
sealed class Resultado
class Exito(val mensaje: String) : Resultado()
class Error(val codigo: Int) : Resultado()

fun mostrarResultado(res: Resultado) {
    when (res) {
        is Exito -> println("√âxito: ${res.mensaje}")
        is Error -> println("Error: ${res.codigo}")
    }
}

fun main() {
    val res1: Resultado = Exito("Todo sali√≥ bien")
    val res2: Resultado = Error(404)

    mostrarResultado(res1)  // √âxito: Todo sali√≥ bien
    mostrarResultado(res2)  // Error: 404
}

```

